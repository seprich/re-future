// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Future$SeprichReFuture = require("./Future.bs.js");

function make(delegateFn) {
  return Future$SeprichReFuture.make((function (setter) {
                var resolveCb = function (value) {
                  return Curry._1(setter, /* Ok */Block.__(0, [value]));
                };
                var rejectCb = function (value) {
                  return Curry._1(setter, /* Error */Block.__(1, [value]));
                };
                return Curry._2(delegateFn, resolveCb, rejectCb);
              }));
}

function fromValue(value) {
  return Future$SeprichReFuture.fromValue(/* Ok */Block.__(0, [value]));
}

function fromError(error) {
  return Future$SeprichReFuture.fromValue(/* Error */Block.__(1, [error]));
}

function fromJsPromise(jsPromise, errorConverter) {
  return Future$SeprichReFuture.make((function (setter) {
                jsPromise.then((function (value) {
                          return Promise.resolve(Curry._1(setter, /* Ok */Block.__(0, [value])));
                        })).catch((function (error) {
                        return Promise.resolve(Curry._1(setter, /* Error */Block.__(1, [Curry._1(errorConverter, error)])));
                      }));
                return /* () */0;
              }));
}

function toJsPromise(future, errorConverter) {
  return new Promise((function (resolve, reject) {
                Future$SeprichReFuture.effect(future, (function (result) {
                        if (result.tag) {
                          reject(Curry._1(errorConverter, result[0]));
                        } else {
                          resolve(result[0]);
                        }
                        return /* () */0;
                      }));
                return /* () */0;
              }));
}

function convertPromiseErrorToExn(error) {
  var retype = ( function(e) { return e; } );
  try {
    throw retype(error);
  }
  catch (raw_error){
    return Caml_js_exceptions.internalToOCamlException(raw_error);
  }
}

function fromJsPromiseDefault(jsPromise) {
  return fromJsPromise(jsPromise, convertPromiseErrorToExn);
}

function toJsPromiseDefault(future) {
  return toJsPromise(future, (function (x) {
                return x;
              }));
}

function mapOk(future, fn) {
  return Future$SeprichReFuture.map(future, (function (result) {
                if (result.tag) {
                  return /* Error */Block.__(1, [result[0]]);
                } else {
                  return /* Ok */Block.__(0, [Curry._1(fn, result[0])]);
                }
              }));
}

function mapError(future, fn) {
  return Future$SeprichReFuture.map(future, (function (result) {
                if (result.tag) {
                  return /* Error */Block.__(1, [Curry._1(fn, result[0])]);
                } else {
                  return /* Ok */Block.__(0, [result[0]]);
                }
              }));
}

function mapOkResult(future, fn) {
  return Future$SeprichReFuture.map(future, (function (result) {
                if (result.tag) {
                  return /* Error */Block.__(1, [result[0]]);
                } else {
                  return Curry._1(fn, result[0]);
                }
              }));
}

function mapErrorResult(future, fn) {
  return Future$SeprichReFuture.map(future, (function (result) {
                if (result.tag) {
                  return Curry._1(fn, result[0]);
                } else {
                  return /* Ok */Block.__(0, [result[0]]);
                }
              }));
}

function flatMapOk(future, fn) {
  return Future$SeprichReFuture.flatMap(future, (function (result) {
                if (result.tag) {
                  return Future$SeprichReFuture.fromValue(/* Error */Block.__(1, [result[0]]));
                } else {
                  return Curry._1(fn, result[0]);
                }
              }));
}

function flatMapError(future, fn) {
  return Future$SeprichReFuture.flatMap(future, (function (result) {
                if (result.tag) {
                  return Curry._1(fn, result[0]);
                } else {
                  return Future$SeprichReFuture.fromValue(/* Ok */Block.__(0, [result[0]]));
                }
              }));
}

function effectOk(future, fn) {
  return Future$SeprichReFuture.effect(future, (function (result) {
                if (result.tag) {
                  return /* () */0;
                } else {
                  return Curry._1(fn, result[0]);
                }
              }));
}

function effectError(future, fn) {
  return Future$SeprichReFuture.effect(future, (function (result) {
                if (result.tag) {
                  return Curry._1(fn, result[0]);
                } else {
                  return /* () */0;
                }
              }));
}

function waitEffectOk(future, fn) {
  return Future$SeprichReFuture.waitEffect(future, (function (result) {
                if (result.tag) {
                  return Future$SeprichReFuture.fromValue(/* () */0);
                } else {
                  return Curry._1(fn, result[0]);
                }
              }));
}

function waitEffectError(future, fn) {
  return Future$SeprichReFuture.waitEffect(future, (function (result) {
                if (result.tag) {
                  return Curry._1(fn, result[0]);
                } else {
                  return Future$SeprichReFuture.fromValue(/* () */0);
                }
              }));
}

function allOk(futures) {
  var reducer = function (accum, item) {
    if (!accum.tag && !item.tag) {
      return /* Ok */Block.__(0, [Belt_List.add(accum[0], item[0])]);
    }
    if (item.tag) {
      return /* Error */Block.__(1, [item[0]]);
    } else {
      return /* Error */Block.__(1, [accum[0]]);
    }
  };
  return Future$SeprichReFuture.map(Future$SeprichReFuture.all(futures), (function (results) {
                return Belt_List.reduceReverse(results, /* Ok */Block.__(0, [/* [] */0]), reducer);
              }));
}

function getOk(future, fn) {
  return Future$SeprichReFuture.get(future, (function (result) {
                if (result.tag) {
                  return /* () */0;
                } else {
                  return Curry._1(fn, result[0]);
                }
              }));
}

function getError(future, fn) {
  return Future$SeprichReFuture.get(future, (function (result) {
                if (result.tag) {
                  return Curry._1(fn, result[0]);
                } else {
                  return /* () */0;
                }
              }));
}

function ignore(future) {
  return Future$SeprichReFuture.map(future, (function (prim) {
                return /* () */0;
              }));
}

var fromResult = Future$SeprichReFuture.fromValue;

var mapResult = Future$SeprichReFuture.map;

var flatMapResult = Future$SeprichReFuture.flatMap;

var effectResult = Future$SeprichReFuture.effect;

var waitEffectResult = Future$SeprichReFuture.waitEffect;

var allToFutureOfResults = Future$SeprichReFuture.all;

var getResult = Future$SeprichReFuture.get;

exports.make = make;
exports.fromJsPromiseDefault = fromJsPromiseDefault;
exports.toJsPromiseDefault = toJsPromiseDefault;
exports.fromJsPromise = fromJsPromise;
exports.toJsPromise = toJsPromise;
exports.fromValue = fromValue;
exports.fromError = fromError;
exports.fromResult = fromResult;
exports.mapOk = mapOk;
exports.mapError = mapError;
exports.mapOkResult = mapOkResult;
exports.mapErrorResult = mapErrorResult;
exports.mapResult = mapResult;
exports.flatMapOk = flatMapOk;
exports.flatMapError = flatMapError;
exports.flatMapResult = flatMapResult;
exports.effectOk = effectOk;
exports.effectError = effectError;
exports.effectResult = effectResult;
exports.waitEffectOk = waitEffectOk;
exports.waitEffectError = waitEffectError;
exports.waitEffectResult = waitEffectResult;
exports.allOk = allOk;
exports.allToFutureOfResults = allToFutureOfResults;
exports.getOk = getOk;
exports.getError = getError;
exports.getResult = getResult;
exports.ignore = ignore;
/* No side effect */
